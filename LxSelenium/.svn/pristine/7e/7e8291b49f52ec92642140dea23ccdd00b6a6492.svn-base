package com.lucernex.qa.iwms.domain;

//////////////////////////////////////////////////////////////////////////////
// Copyright 2011 Lucernex, Inc.  All rights reserved.
//
// $RCSfile$
// $Author: bobc $
// $Date: 2011-01-12 16:10:03 -0800 (Wed, 12 Jan 2011) $
// $Revision: 15696 $
//////////////////////////////////////////////////////////////////////////////

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ls.DOMImplementationLS;
import org.w3c.dom.ls.LSOutput;
import org.w3c.dom.ls.LSSerializer;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringBufferInputStream;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

/** Class to help with basic DOM Manipulation.
 *  Currently part of ReportFilter package and so not allowed any File access for security
 *  (accordingly similar to DOMUtil without File support).  Also due to this does not use LxCategory
 *  for logging.
 */
public class LxDOMUtil {
    static Logger logger = Logger.getLogger(LxDOMUtil.class.getName());

    private Document mDocument = null;
    private boolean mDirty = false;

    ///////////////////////////////////////////////////////////////////////////
    /**
     * Create a new (empty) DOM for building upon
     */
    public LxDOMUtil(String rootTag) {
        try {
            DocumentBuilderFactory docFactory = getDocumentFactory();

            mDocument = docFactory.newDocumentBuilder().newDocument();
            Element root = mDocument.createElement(rootTag);
            mDocument.appendChild(root);

        } catch (Exception e) {
            logger.log(Level.SEVERE, "unexpected", e);
        }
    }

    private LxDOMUtil() {
        try {
            //mDocument = new DocumentImpl();
            mDocument = getDocumentFactory().newDocumentBuilder().newDocument();
        } catch (Exception e) {
            logger.log(Level.SEVERE, "unexpected", e);
        }
    }

    // Be consistent about factory we use, older apache doesn't support xml serialize correctly
    private static DocumentBuilderFactory getDocumentFactory() {
        DocumentBuilderFactory docFactory =
                DocumentBuilderFactory.newInstance("com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl",
                        null);
        //System.out.println(docFactory.getClass().getName());
        return docFactory;
    }

    ///////////////////////////////////////////////////////////////////////////
    /**
     * Load DOM for a String/Stream
     * @throws javax.xml.parsers.ParserConfigurationException
     */
    public LxDOMUtil(java.io.Reader characterStream)
            throws InvocationTargetException,
            ParserConfigurationException
    {
        this( new InputSource(characterStream) );
    }

    ///////////////////////////////////////////////////////////////////////////
    /**
     * Load DOM from InputSource
     * @throws ParserConfigurationException
     */
    public LxDOMUtil(InputSource in)
            throws InvocationTargetException,
            ParserConfigurationException
    {
        // Load document
        loadDOM( in );
    }

    ///////////////////////////////////////////////////////////////////////////
    /**
     * Load and return DOM for given file.
     */

    private void loadDOM (InputSource in)
            throws InvocationTargetException
    {
        DocumentBuilderFactory factory = getDocumentFactory();

        String errorMsg = null;
        Exception error = null;
        try {
            DocumentBuilder builder = factory.newDocumentBuilder();

            // Update our document
            mDocument = builder.parse( in );
        } catch (SAXParseException spe) {
            // Error generated by the parser
            errorMsg = "\n** Parsing error"
                    + ", line " + spe.getLineNumber()
                    + ", uri " + spe.getSystemId()
                    + "\n" + spe.getMessage();

            // Use the contained exception, if any
            error = spe;
            if (spe.getException() != null)  {
                error = spe.getException();
            }
        } catch (SAXException sxe) {
            // Error generated by this application
            // (or a parser-initialization error)
            // Use the contained exception, if any
            error = sxe;
            if (sxe.getException() != null)  {
                error = sxe.getException();
            }
        } catch (ParserConfigurationException pce) {
            // Parser with specified options can't be built
            error = pce;

        } catch (IOException ioe) {
            // I/O error
            error = ioe;
        }
        if (error != null)  {
            // Exception occurred, log and rethrow.
            if (errorMsg == null)  {
                errorMsg = "Failed to parse/load XML document";
            }
            logger.log(Level.SEVERE, errorMsg, error);
            throw new InvocationTargetException(error, errorMsg);
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get current DOM for given file.
     */
    public Document getDocument ()
    {
        return mDocument;
    }

    ///////////////////////////////////////////////////////////////////////////
    /**
     * Retrieves an attribute value by name.
     * @param name The name of the attribute to retrieve.
     * @return The <code>Attr</code> value as a string, or the empty string
     *   if that attribute does not have a specified or default value.
     */

    public String getAttribute(String name) {
        Element parent = getDocument().getDocumentElement();
        return parent.getAttribute(name);
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get childNode of interest (this routine assumes only one such element)
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return element or null if not found.  SAXException thrown if more than one tag found
     */

    public Element getOptionalTagElement(Element parent, String tagName)
            throws SAXException
    {
        if (parent == null)  {
            parent = getDocument().getDocumentElement();
        }
        // Find tag element.
        Element tag = null;
        NodeList childNodes = parent.getChildNodes();
        for (int j = 0; j < childNodes.getLength(); j++){
            Node n = childNodes.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE &&
                    n.getNodeName().equals(tagName)) {
                // Found one.
                if (tag != null)  {
                    // More than one present.
                    throw new SAXException("Error: found more than one tag=\"" + tagName +
                            "\" within tag=\"" + parent.getNodeName() + "\"");
                }
                tag = (Element)n;
            }
        }
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get childNode of interest (this routine assumes only one such element)
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return element or null if not found.  SAXException thrown if more than one tag found
     */

    public Element getRequiredTagElement(Element parent, String tagName)
            throws SAXException
    {
        Element tag = getOptionalTagElement(parent, tagName);
        if (parent == null)  {
            parent = getDocument().getDocumentElement();
        }
        if (tag == null)  {
            // Didn't find the required tag.
            throw new SAXException("Error: Didn't find tag=\"" + tagName +
                    "\" within tag=\"" + parent.getNodeName() + "\"");
        }
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get childNodes of interest
     *  @param parent -- Element to look for tags under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return elements or null if not found.  SAXException thrown if more than one tag found
     */

    public Element[] getOptionalTagElementArray(Element parent, String tagName)
            throws SAXException
    {
        if (parent == null)  {
            parent = getDocument().getDocumentElement();
        }
        // Find tag elements.
        Vector<Node> tags = new Vector<Node>();
        NodeList childNodes = parent.getChildNodes();
        for (int j = 0; j < childNodes.getLength(); j++){
            Node n = childNodes.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE &&
                    n.getNodeName().equals(tagName)) {
                //tag = (Element)n;
                tags.add( n );
            }
        }
        Element[] tagArray = new Element[ tags.size() ];
        tagArray = (Element[])(tags.toArray(tagArray));
        return tagArray;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get childNodes of interest
     *  @param parent -- Element to look for tags under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return elements or null if not found.  SAXException thrown if more than one tag found
     */

    public Element[] getRequiredTagElementArray(Element parent, String tagName)
            throws SAXException
    {
        Element[] tagList = getOptionalTagElementArray(parent, tagName);

        if (tagList == null)  {
            // Didn't find the required tag.
            throw new SAXException("Error: Didn't find tag=\"" + tagName +
                    "\" within tag=\"" + parent.getNodeName() + "\"");
        }

        return tagList;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get CDATA or text value from childNode of specified element.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of tag to get value for
     *  @return value or "" (empty string) if not found.
     */

    public String getOptionalTagValue(Element parent, String tagName)
            throws SAXException
    {
        // First find tag element.
        Element tag = getOptionalTagElement(parent, tagName);
        return getOptionalTagValue( tag );
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get CDATA or text value from childNode of specified element.
     *  @param parentTag -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of tag to get value for
     *  @return value or "" (empty string) if not found.
     */

    public String getTagValue(String parentTag, String tagName)
            throws SAXException
    {
        // First find tag element.
        Element root = getDocument().getDocumentElement();
        NodeList childNodes = root.getChildNodes();
        Element parent = null;
        for (int j = 0; j < childNodes.getLength(); j++){
            Node n = childNodes.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE &&
                    n.getNodeName().equals(parentTag)) {
                parent = (Element)n;
                break;
            }
        }
        if(parent != null){
            // First find tag element.
            Element tag = getOptionalTagElement(parent, tagName);
            return getOptionalTagValue( tag );
        }
        return null;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get CDATA or text value from specified element.
     *  @param tag -- Element to get value for
     *  @return value or "" (empty string) if not found.
     */

    public static String getOptionalTagValue(Element tag)
            throws SAXException
    {
        String value = "";
        if (tag != null)  {
            // Prefer cdata value over text value
            NodeList valueNodes = tag.getChildNodes();
            for (int idx=0; idx<valueNodes.getLength(); idx++)  {
                Node vn = valueNodes.item(idx);
                if (vn.getNodeType() == Node.TEXT_NODE) {
                    if (value.length() > 0)  {
                        // space delimit tokens across lines (eat all other whitespace)
                        value += " ";
                    }
                    value += trimMultiLineWhiteSpace(vn.getNodeValue());
                } else if (vn.getNodeType() == Node.CDATA_SECTION_NODE)  {
                    value = vn.getNodeValue();
                    break;				// Use cdata value.
                }
            }
        }
        return value;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get CDATA or text value from childNode of specified element.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of tag to get value for
     *  @return value
     */

    public String getRequiredTagValue(Element parent, String tagName)
            throws SAXException
    {
        String value = "";
        // First find tag element.
        Element tag = getRequiredTagElement(parent, tagName);
        if (tag != null)  {
            // Prefer cdata value over text value
            NodeList valueNodes = tag.getChildNodes();
            for (int idx=0; idx<valueNodes.getLength(); idx++)  {
                Node vn = valueNodes.item(idx);
                if (vn.getNodeType() == Node.TEXT_NODE) {
                    if (value.length() > 0)  {
                        // space delimit tokens across lines (eat all other whitespace)
                        value += " ";
                    }
                    value += trimMultiLineWhiteSpace(vn.getNodeValue());
                } else if (vn.getNodeType() == Node.CDATA_SECTION_NODE)  {
                    value = vn.getNodeValue();
                    break;				// Use cdata value.
                }
            }
        }
        return value;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get Element of interest by looking for tag with specified
     *  attribute value.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @param tagAttributeName -- name of attribute to search for
     *  @param tagAttributeValue -- value which specifies match
     *  @return element or null if not found.
     */

    public Element getOptionalElementByAttribute(
            Element parent,
            String tagName,
            String tagAttributeName,
            String tagAttributeValue)
            throws SAXException
    {
        if (parent == null)  {
            parent = getDocument().getDocumentElement();
        }
        // Find tag element.
        Element tag = null;
        NodeList childNodes = parent.getChildNodes();
        for (int j = 0; j < childNodes.getLength(); j++){
            Node n = childNodes.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE &&
                    n.getNodeName().equals(tagName)) {
                Element temp = (Element)n;
                if (tagAttributeValue.equals(temp.getAttribute(tagAttributeName)))  {
                    // Found one.
                    if (tag != null)  {
                        // More than one present.
                        throw new SAXException("Error: found more than one tag=\"" +
                                tagName + "\" with '" + tagAttributeName + "=" + tagAttributeValue +
                                "' within tag=\"" + parent.getNodeName() + "\"");
                    }
                    tag = (Element)n;
                }
            }
        }
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get Element attribute value of interest
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @param tagAttributeName -- name of attribute to search for
     *  @param tagAttributeValue -- value which specifies match
     *  @return value of element
     */

    public String getOptionalElementValueByAttribute(
            Element parent,
            String tagName,
            String tagAttributeName,
            String tagAttributeValue)
            throws SAXException
    {
        String value = "";
        // First find tag element.
        Element tag = getOptionalElementByAttribute(parent, tagName, tagAttributeName, tagAttributeValue);
        if (tag != null)  {
            // Prefer cdata value over text value
            NodeList valueNodes = tag.getChildNodes();
            for (int idx=0; idx<valueNodes.getLength(); idx++)  {
                Node vn = valueNodes.item(idx);
                if (vn.getNodeType() == Node.TEXT_NODE) {
                    if (value.length() > 0)  {
                        // space delimit tokens across lines (eat all other whitespace)
                        value += " ";
                    }
                    value += trimMultiLineWhiteSpace(vn.getNodeValue());
                } else if (vn.getNodeType() == Node.CDATA_SECTION_NODE)  {
                    value = vn.getNodeValue();
                    break;				// Use cdata value.
                }
            }
        }
        return value;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Find element of interest.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of tags to search thru
     *  @param subTagName -- tag to look for match in
     *  @param subTagValue -- value of subTag for a match
     *  @return Element of interest or null
     */

    public Element getOptionalElementBySubTag(Element parent, String tagName, String subTagName, String subTagValue)
            throws SAXException
    {
        if (parent == null)  {
            parent = getDocument().getDocumentElement();
        }
        // Look for tag
        Element tag = null;
        NodeList childNodes = parent.getChildNodes();
        for (int j = 0; j < childNodes.getLength(); j++){
            Node n = childNodes.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE &&
                    n.getNodeName().equals(tagName)) {
                tag = (Element)n;
                // Possible match, see if have value match on subtag.
                String value = getOptionalTagValue(tag, subTagName);
                if (value.equals(subTagValue))  {
                    // Found it.
                    return tag;
                }
            }
        }
        return null;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Return list of all elements with specified tagName.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName	-- Tag name to retrieve elements for or null for
     *                     all child Elements of parent.
     */

    public Element[] getAllElements(Element parent, String tagName) {
        Vector<Element> elems = new Vector<Element>();
        if (parent == null)  {
            parent = getDocument().getDocumentElement();
        }
        // Look for tag
        NodeList childNodes = parent.getChildNodes();
        for (int j = 0; j < childNodes.getLength(); j++){
            Node n = childNodes.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE &&
                    (tagName == null ||
                            n.getNodeName().equals(tagName)) )
            {
                // Add this one.
                elems.add((Element)n);
            }
        }
        Element[] retList = elems.toArray(new Element[elems.size()]);
        return retList;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get childNode of interest creating it if necessary.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of element tag
     *  @param tagAttributeName -- name of attribute to search for
     *  @param tagAttributeValue -- value which specifies match
     *  @return element .  SAXException thrown if more than one tag found
     */

    public Element getCreateTagElementByAttribute(
            Element parent,
            String tagName,
            String tagAttributeName,
            String tagAttributeValue)
            throws SAXException
    {
        // First lookup existing tag element.
        Element tag = getOptionalElementByAttribute(parent, tagName, tagAttributeName, tagAttributeValue);
        if (tag == null)  {
            // Add it.
            tag = createTagElement(parent, tagName);
            tag.setAttribute(tagAttributeName, tagAttributeValue);
            markDirty();
        }
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Add/update value for our DOM representation
     *  All values added as CDATA items.
     */

    public void updateTextValue(Element parent, String tagName, String value)  {
        updateElementValue(parent, tagName, value, true);
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Add/update element value within DOM
     *  @param parent -- element being updated/added will be a child of
     *					 this element or pass null if this is top-level element
     *  @param tagName	-- Name of tag
     *	@param value -- CDATA section value
     */

    public void updateCDATAValue(Element parent, String tagName, String value)  {
        updateElementValue(parent, tagName, value, false);
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Add/update value for our DOM representation
     *  @param tag	-- Element to update value for
     *	@param value -- text value
     */

    public void updateTextValue(Element tag, String value)  {
        updateExistingElementValue(tag, value, true);
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Add/update element value within DOM
     *  @param tag	-- Element to update value for
     *	@param value -- CDATA section value
     */

    public void updateCDATAValue(Element tag, String value)  {
        updateExistingElementValue(tag, value, false);
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Remove a childNode managing dirtyFlag.
     *  @param parent -- Element tag is under
     *  @param toRemove -- Element to remove
     */

    public void removeElement(Element parent, Element toRemove)
    {
        parent.removeChild(toRemove);
        markDirty();
    }

    /** Get childNode of interest creating it if necessary.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return element .  SAXException thrown if more than one tag found
     */
    public static Element getCreateTagElement(Document doc, Element parent, String tagName)
    {
        if (parent == null)  {
            parent = doc.getDocumentElement();
        }
        // Find tag element.
        Element tag = null;
        NodeList childNodes = parent.getChildNodes();
        for (int j = 0; j < childNodes.getLength(); j++){
            Node n = childNodes.item(j);
            if (n.getNodeType() == Node.ELEMENT_NODE &&
                    n.getNodeName().equals(tagName)) {
                // Found one.
                if (tag != null)  {
                    // More than one present.
                    throw new RuntimeException("Error: found more than one tag=\"" + tagName + "\" within tag=\"" + parent.getNodeName() + "\"");
                }
                tag = (Element)n;
            }
        }
        if (tag == null)  {
            // Add it.
            tag = createTagElement(doc, parent, tagName);
        }
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Get childNode of interest creating it if necessary.
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return element .  SAXException thrown if more than one tag found
     */
    public Element getCreateTagElement(Element parent, String tagName)
    {
        Element tag = getCreateTagElement(getDocument(), parent, tagName);
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Create childNode of interest
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return element
     */
    public static Element createTagElement(Document doc, Element parent, String tagName) {
        if (parent == null)  {
            parent = doc.getDocumentElement();
        }
        // Add it.
        Element tag = doc.createElement(tagName);
        parent.appendChild(tag);
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Create childNode of interest
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return element
     */
    public Element createTagElement(Element parent, String tagName) {
        Element tag = createTagElement(getDocument(), parent, tagName);
        markDirty();
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Create childNode of interest
     *  @param parent -- Element to look for tag under, or null if should use root element.
     *  @param tagName -- name of elemnt tag
     *  @return element
     */

    public Element createTagElement(Element parent, String tagName, String value ) {
        if (parent == null)  {
            parent = getDocument().getDocumentElement();
        }
        // Add it.
        Element tag = getDocument().createElement(tagName);
        parent.appendChild(tag);
        updateExistingElementValue(tag, value, true);
        markDirty();
        return tag;
    }

    ///////////////////////////////////////////////////////////////////////////

    /** Update the value for specified tagName in the Document.
     *  If parent not specified docRoot assumed (i.e. top-level tag).
     *  If Element with tagName does not currently exist it will be created.
     *
     *  @param updateText -- true to update TextNode, else updates CData node
     */
    public static void updateElementValue(Document doc, Element parent, String tagName, String value, boolean updateText)  {
        Element tag = getCreateTagElement(doc, parent, tagName);
        // Create/update cdata value.
        updateExistingElementValue(doc, tag, value, updateText);
    }

    ///////////////////////////////////////////////////////////////////////////

    private void updateElementValue(Element parent, String tagName, String value, boolean updateText)  {
        Element tag = getCreateTagElement(parent, tagName);
        // Create/update cdata value.
        updateExistingElementValue(tag, value, updateText);
    }

    ///////////////////////////////////////////////////////////////////////////

    private void updateExistingElementValue(Element tag,String value, boolean updateText)  {
        updateExistingElementValue(getDocument(), tag, value, updateText);
        markDirty();
    }

    ///////////////////////////////////////////////////////////////////////////

    private static void updateExistingElementValue(Document doc, Element tag, String value, boolean updateText)  {
        // Create/update cdata value.
        NodeList valueNodes = tag.getChildNodes();
        Node cdataNode = null;
        Node textNode = null;
        for (int idx=0; idx<valueNodes.getLength(); idx++)  {
            Node vn = valueNodes.item(idx);
            if (vn.getNodeType() == Node.CDATA_SECTION_NODE)  {
                cdataNode = vn;
            } else if (vn.getNodeType() == Node.TEXT_NODE)  {
                textNode = vn;
            }
        }
        if (updateText)  {
            if (textNode == null)  {
                // create text node.
                textNode = doc.createTextNode(value);
                tag.appendChild(textNode);
            }
            textNode.setNodeValue(value);
        } else  {
            if (cdataNode == null)  {
                // create cdata node.
                cdataNode = doc.createCDATASection(value);
                tag.appendChild(cdataNode);
            }
            cdataNode.setNodeValue(value);
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    /** If you add elements you should update as dirty... */

    public void markDirty()  {
        mDirty = true;
    }

    ///////////////////////////////////////////////////////////////////////////
    /**
     *  Converts this stuff:
     *  &lt; < less than
     *  &gt; > greater than
     *  &amp; & ampersand
     *  &apos; ' apostrophe
     *  &quot; " quotation mark
     */

    public static String xmlEscape(String source) {
        // hackomatic to encode chars in the filename.
        String nextToParse = source;
        if(nextToParse == null){
            return null;
        }
        // Eat initial control characters.
        while (nextToParse.length() > 0 && nextToParse.charAt(0) < ' ')  {
            nextToParse = nextToParse.substring(1, nextToParse.length());
        }
        // List escape characters.  Note backslash must be first !!
        int [] escapeChars =  {'"','\'','>','<','&'};
        String [] replaceStrs =  {"&quot;","&apos;","&gt;","&lt;","&amp;"};
        for (int i=0; i<escapeChars.length; i++)  {
            StringBuffer output = new StringBuffer();
            int curOffset = 0;
            int offset;
            while (curOffset < nextToParse.length() &&
                    (offset = nextToParse.indexOf(escapeChars[i], curOffset)) != -1) {
                output.append(nextToParse.substring(curOffset, offset));
                // Escape character properly.
                output.append(replaceStrs[i]);
                curOffset = offset + 1;
            }
            if (curOffset < nextToParse.length()) {
                // Add in remainder, no more escaped characters.
                output.append(nextToParse.substring(curOffset));
            }
            // Prepare for next character
            nextToParse = output.toString();
        }
        return nextToParse;
    }

    ///////////////////////////////////////////////////////////////////////////
    /** Manage whitespace properly for reading from xml file (Text,not CDATA sections)
     */

    private static String trimMultiLineWhiteSpace(String source)  {
        // Eat initial control characters (e.g. CR/LF)
        String remaining = source.trim();
        if(remaining == null){
            return null;
        }
        // List escape characters.  Note ' ', space must be last!
        int [] escapeChars =  {0x0D, 0x0A, 0x0C, ' '};
        for (int i=0; i<escapeChars.length; i++)  {
            if (escapeChars[i] == ' ' && -1 == remaining.indexOf("  "))  {
                // We are only interested in reducing multiple spaces to single
                // ones, if all we have is single spaces left we are done.
                break;
            }
            String output = "";
            int offset;
            while ((offset = remaining.indexOf(escapeChars[i])) != -1) {
                // rip off more...
                if (output.length() > 0) {
                    output += " ";
                }
                output += remaining.substring(0, offset).trim();
                // Eat initial whitespace in remainder.
                remaining = remaining.substring(offset, remaining.length()).trim();
            }
            if (remaining.length() > 0)  {
                // Add in rest.
                if (output.length() > 0) {
                    output += " ";
                }
                output += remaining;
            }
            // Prepare for next character
            remaining = output;
        }
        return remaining;
    }

    ///////////////////////////////////////////////////////////////////////////
    /**
     * Write out DOM as String
     * @return String Contents of DOM
     */
    public String toXMLString() throws IOException {
        ByteArrayOutputStream ba = new ByteArrayOutputStream();

        toXMLString(ba);

        return ba.toString();
    }

    ///////////////////////////////////////////////////////////////////////////
    /**
     * Write out DOM as String
     * @param out -- SYSTEM doc type or null if none.
     * @return String Contents of DOM
     */
    public void toXMLString(OutputStream out) throws IOException {
        DOMImplementationLS DOMiLS=null;

        // See if support for DOM Load and Save
        if(mDocument.getFeature("Core","3.0") == null ||
                mDocument.getFeature("LS","3.0") == null) {
            // No support, old parser...
            throw new IOException("DOM Load and Save unsupported for " + mDocument.getClass().getName());
        }

        if (getDocument().getDocumentElement() == null) {
            throw new IOException("Unable to save DOM - no root Element exists (i.e. empty DOM!)" + mDocument.getClass().getName());
        }

        DOMiLS = (DOMImplementationLS)(mDocument.getImplementation())
                .getFeature("LS","3.0");

        try {
            //get a LSOutput object
            LSOutput LSO = DOMiLS.createLSOutput();
            LSO.setEncoding("UTF-8");
            LSO.setByteStream(out);

            //get a LSSerializer object
            LSSerializer LSS=DOMiLS.createLSSerializer();
            //LSS.getDomConfig().setParameter("canonical-form", true);
            if (LSS.getDomConfig().canSetParameter("format-pretty-print", Boolean.TRUE)) {
                LSS.getDomConfig().setParameter("format-pretty-print", Boolean.TRUE);
            }

            //do the serialization
            LSS.write(mDocument,LSO);

        } catch (Exception e) {
            logger.log(Level.SEVERE, "Unable to serialize DOM to XML", e);
            throw new IOException("Unable to serialize DOM to XML: " + e);
        }
    }

    /** Lightweight storage for xml chunk of data (not associated with file)
     * */
    public static class DOMChunk {
        final Document doc;
        LxDOMUtil domBuilder = null;
        Map<String, String> valueMap = null;

        /** Create one from xml snippet -- e.g. going to read xml snippet vals */
        public DOMChunk(String xml)
                throws SAXException, ParserConfigurationException, SAXException, IOException
        {
            if (xml == null) {
                // must have lost our xml values... give up so we don't blow away data
                throw new SAXException("Data errror: unable to munge dom as null xml value for DOMChunk()!");
            }
            DocumentBuilder bldr = getDocumentFactory().newDocumentBuilder();
            doc = bldr.parse(new StringBufferInputStream(xml));
        }

        /** Create one from key/value map -- e.g. going to write out xml snippet
         *  @param rootTag -- tag to contain the vals
         *  @param inputVals -- key/value pairs.  Note simply call toString on vals for formatting
         *  @param keyPrefix - prefix for key (not specified in inputVals keys but added to xml tagname key)
         * */
        public DOMChunk(String rootTag, Map<String, Object>inputVals, String keyPrefix)
                throws SAXException, ParserConfigurationException, SAXException, IOException
        {
            domBuilder = new LxDOMUtil();
            doc = domBuilder.mDocument;
            Element root = doc.createElement(rootTag);
            doc.appendChild(root);

            for (String key : inputVals.keySet()) {
                Object val = inputVals.get(key);
				/*
				if (val != null && !(val instanceof String)) {
					Float fVal = (Float)val;
					System.out.println(fVal.toString() + ", float val =" + fVal.longValue());
					System.out.println(val.getClass().getName());
				}
				*/
                String sVal = (val == null) ? "" : val.toString();
                domBuilder.updateTextValue(root, (keyPrefix != null ? keyPrefix : "") + key, sVal);
            }
        }

        /** Get a value for key.  Note assumes tag/value where tagName=key.
         *  This method doesn't support nested tags, i.e. assumes 'flat' xml
         *  of tag/value
         */
        public String getValue(String key)
                throws SAXException,
                ParserConfigurationException, SAXException, IOException
        {
            NodeList nodes = doc.getDocumentElement().getElementsByTagName(key);
            Element keyNode;
            for (int idx=0; idx<nodes.getLength(); idx++) {
                if (nodes.item(idx) instanceof Element) {
                    // for now only support one node
                    keyNode = (Element)nodes.item(idx);
                    String val = LxDOMUtil.getOptionalTagValue(keyNode);
                    return val;
                }
            }
            return "";
        }

        /** Get list of tags, i.e. keys
         */
        public synchronized Map<String, String> getValueMap()
                throws SAXException,
                ParserConfigurationException, SAXException, IOException
        {
            return getValueMap(null);
        }

        /** Get list of tags, i.e. keys ripping off a prefix
         */
        public synchronized Map<String, String> getValueMap(String prefix)
                throws SAXException,
                ParserConfigurationException, SAXException, IOException
        {
            if (valueMap == null) {
                valueMap = new HashMap<String, String>();
                NodeList nodes = doc.getDocumentElement().getChildNodes();
                Element keyNode;
                for (int idx=0; idx<nodes.getLength(); idx++) {
                    if (nodes.item(idx) instanceof Element) {
                        // for now only support one node
                        keyNode = (Element)nodes.item(idx);
                        String val = LxDOMUtil.getOptionalTagValue(keyNode);
                        String key = keyNode.getTagName();
                        if (prefix != null && key.startsWith(prefix)) {
                            key = key.substring(prefix.length());
                        }
                        valueMap.put(key, val);
                    }
                }
            }
            return valueMap;
        }

        /** Get xml snippet for this xml, i.e. no encoding/doctype such that
         *  first tag is first DOM element.
         */
        public String toXMLString() throws IOException {
            if (domBuilder == null) {
                domBuilder = new LxDOMUtil();
                // set to our current doc.
                domBuilder.mDocument = doc;
            }
            String xml = domBuilder.toXMLString();
            if (xml.indexOf("?>") < 200) {
                xml = xml.substring(xml.indexOf("?>") + 2);
            }
            return xml;
        }
    }
}
